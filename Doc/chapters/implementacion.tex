En este capítulo se hablará sobre la implementación realizada. Primero, se introducirá el \emph{hardware} utilizado. Luego, se explicará de que manera se procesaron las distintas señales, desde la obtención de las mismas hasta las características y clasificadores utilizados. Finalmente, se hablará de los universos 3D interactivos desarrollados. Los universos 3D fueron desarrollados en el lenguaje \emph{C\#} en \emph{Unity}.

\section{Hardware}

Para la elección del \emph{hardware} se tuvieron en cuenta distintos criterios. Principalmente se busco un compromiso entre costo y fiabilidad pero también se tuvo en cuenta su facilidad de uso.

\subsection{EEG}

En el caso de EEG, se decidió utilizar el \emph{Muse Brainsensing Headband}. Este dispositivo cuenta cuenta con siete electrodos y diversas funcionalidades. En la figura \ref{fig:muse-electrodes} se puede observar la configuración del dispositivo. Cuenta con tres electrodos de referencia sobre la frente, dos electrodos frontales y dos electrodos en las orejas. Los electrodos de referencia se utilizan para medir el nivel de potencial eléctrico. Es decir, el potencial de los restantes electrodos, se mide en base a los electrodos de referencia.

\begin{figure}[H]
	\centering
    \includegraphics[width=0.8\textwidth]{muse-electrodes.png}
    \caption{Diagrama de la ubicación de los electrodos en el \emph{Muse Brainsensing Headband}. AF7 y AF8 son los electrodos frontales, TP9 y TP10 los electrodos en las orejas y Fpz representa los tres electrodos de referencia \cite{muse-hardware}.}
	\label{fig:muse-electrodes}
\end{figure}

El dispositivo tiene una frecuencia de muestreo de $ 256 \, Hz$. Además cuenta con acelerómetro y giroscopio lo que permite medir la orientación del usuario. También cuenta con un puerto micro USB y \emph{bluetooth}. Permite acceder a la información bruta de cada electrodo por lo que se obtienen cinco valores. Cuatro de de los electrodos frontales y de las orejas, y el restante se obtiene de los tres electrodos de referencia. También brinda algunas facilidades como realizar la Transformada de \emph{Fourier},  calcular la potencia de las bandas ($\alpha$, $\beta$, $\delta$, $\theta$ y $\gamma$), entre otros.

Para los desarrolladores, cuenta con \emph{SDK} para \emph{Windows} y \emph{Unity} y cuenta con aplicaciones multiplataforma para poder acceder a los datos. Una forma de acceder a los datos es a través de \emph{OSC} (\emph{Open Sound Control}. \emph{OSC} es un protocolo que corre sobre UDP y permite el \emph{stream} continuo de datos.

\subsection{EMG} \label{emg-hardware}

Para la lectura de señales EMG, se opto por utilizar la plataforma Arduino, con un modulo adicional diseñado para la captura de señales EMG y EKG.  Arduino es una plataforma que consiste en varios micro controladores de diseño abierto (\emph{Open Source Hardware}), y un software que permite programarlos de forma fácil y rápida utilizando el lenguaje de progamación \emph{C++}.

El modelo de Arduino elegido fue el \emph{Arduino Mega 2560}, que cuenta con un procesador que opera a $16\, MHz$, y cuenta con $256 Kb$ de memoria para programas, lo cual prácticamente permite trabajar sin restricciones de memoria en mente. A su vez, el modulo adicional elegido fue el \emph{Olimex SHIELD-EKG-EMG}, que trae electrodos superficiales que pueden ser ubicados sobre la piel del musculo que se intenta monitorear.  Los electrodos cuentan con tres terminales, marcadas con las letras $L$ (izquierda), $R$ (derecha) y $D$ (referencia) (figura \ref{fig:emg-electrodes}).

\begin{figure}[H]
	\centering
    \includegraphics[width=0.5\textwidth]{electrodes.jpg}
    \caption{Electrodos superficiales para el modulo \emph{Olimex SHIELD-EKG-EMG}.}
	\label{fig:emg-electrodes}
\end{figure}

Para poder leer las señales EMG, se debe preparar el sistema de monitoreo.  Primero, se debe montar el modulo EMG sobre el micro controlador \emph{Arduino}.  Luego, las terminales $L$ y $R$ se deben posicionar sobre la piel del musculo a monitorear, y la terminal $D$ debe ser posicionada sobre una superficie del cuerpo a utilizar como referencia, que preferiblemente no contenga musculos, o tenga musculos no relacionados a los de las otras dos terminales (a este circuito se le llama \emph{Driven Right Leg Circuit} en inglés). En este proyecto, se opto por medir la actividad muscular de un brazo, junto a la mano, al formar un puño cerrado apretado. Por lo tanto, los electrodos fueron colocados sobre el músculo flexor común superficial de los dedos, que se encuentra sobre la cara anterior de antebrazo\cite{emg-signals-wrist}. Una vez realizados los pasos anteriores, se puede proceder a conectar el micro controlador a la computadora vía un cable USB 2.0.

\subsection{SPO2}

Para medir el ritmo cardíaco se decidió utilizar el dispositivo \emph{CMS50D+ Contec Pulse Oximeter}. Éste es un pulsioxímetro de transmisión de alta precisión, fácil de utilizar y de bajo consumo. Dicho dispositivo utiliza el puerto serie para enviar datos utilizando un formato propietario. Los datos más relevantes que envía el sensor son:

\begin{itemize}
\item \emph{Picos:}  Indica si hubo un pico.
\item \emph{Ritmo cardíaco:} Estimado utilizando una ventana de 30 segundos.
\item \emph{Oxígeno:} Porcentaje de oxígeno.
\end{itemize} 

El dispositivo se conecta a la computadora con un cable USB 2.0 que internamente transforma de USB a serie. La frecuencia de muestreo es de $256 \, Hz$.

Se decidió utilizar un pulsioxímetro en lugar de un EKG ya que es menos invasivo. El \emph{Olimex SHIELD-EKG-EMG} resultaba muy incómodo de utilizar debido a que uno de los electrodos debía colocarse en una pierna y otro en un brazo, lo que hubiese ocasionado dificultad para operar una computadora mientras se utilizaba. Si bien un dispositivo EKG es más preciso que un pulsioxímetro, estudios han demostrado que la estimación realizada por un pulsioxímetro es muy precisa cuando el ritmo cardíaco se encuentra por debajo del $89\% $ de su máximo \cite{spo2-accuracy}. Como el usuario se encuentra sentado en una computadora, jamás alcanzará dichos valores.

\section{Obtención y Procesamiento de Señales}

Para cada uno de los sensores se evaluaron y aplicaron distintas alternativas sobre como procesar la señal.

\subsection{EEG}

Para leer la señal se decidió utilizó \emph{OSC}. Se tomo esta decisión ya que al momento de iniciar el proyecto, el \emph{SDK} para Windows se encontraba en estado beta por lo que no era confiable. Además implicaba un desarrollo en el lenguaje \emph{C} mientras que el desarrollo se encontraba en \emph{C\#} y, como solo se encontraba disponible para \emph{Windows}, no permitía que el proyecto sea multiplataforma. Tampoco se utilizó el \emph{SDK} para \emph{Unity}, ya que este era únicamente para dispositivos móviles.

Una gran desventaja de este dispositivo, es que no cuenta con soporte para la aplicación \emph{MuseIO}, que permite obtener paquetes \emph{OSC} a través de la computadora. Por este motivo, se terminó utilizando una aplicación móvil llamada \emph{Muse Monitor}, que nos permitió conectar el dispositivo al teléfono celular y desde allí enviar los paquetes \emph{OSC} hacia la computadora. En un principio se pensó que la latencia podría ser un problema ya que cada paquete debe realizar dos trayectos, primero desde el dispositivo hacia el teléfono celular y luego hacia la computadora, pero esto no fue un problema ya que el flujo de datos no era masivo y no eran de gran tamaño.

En un principio, se utilizó un \emph{framework} para procesar los paquetes \emph{OSC} pero este no resultó ser fiable. Se buscaron alternativas pero no hubo ninguna que cumpla con los estándares del equipo. Por este motivo, se desarrollo un procesador de paquetes \emph{OSC} propio. Esto implicó leer el estándar, comprender como funciona e implementarlo.
 
 Los estados que se buscaron detectar fueron ojos abiertos (A) y ojos cerrados (C). Por este motivo, la información que se necesitaba eran las ondas $\alpha$. Como se mencionó anteriormente, el dispositivo \emph{Muse} permitía acceder a la potencia de las ondas $\alpha$ con. Para obtener dichas ondas el dispositivo sigue el siguiente procedimiento:
 
 \begin{enumerate}
 \item Obtener una ventana $25$ muestras (pues envía $10$ muestras por segundo y el sensor obtiene $256$ muestras por segundo) y aplicar la función de ventana $Hann$.
 \item Obtener la Transformada de \emph{Fourier} de la ventana.
 \item Aplicar un filtro pasa banda para utilizar únicamente las frecuencias de interés ( $ 8 \, Hz \leq f \leq 13 \, Hz$).
 \item Realizar la DEP sobre esos valores. A diferencia de solo integrar, el dispositivo aplica $log_{10}$  a cada valor antes de realizar la integral.
 \end{enumerate}

El vector de características se confeccionó utilizando dos valores de \emph{Alpha} consecutivos, es decir, de la siguiente manera:

\[
  \vec{v}^{\, }=
  \left[ {\begin{array}{cc}
   \alpha_{i}  & \alpha_{i + 1}  \     \end{array} } \right]
\]

En la etapa de entrenamiento se le asignaba un estado a cada uno de estos vectores. La precisión obtenida con este método fue de entre un $65\%$ y un $70\%$. Esto se debe a que aún cuando el usuario se encontraba con los ojos abiertos, \emph{Alpha} alcanzaban valores tan altos como cuando el usuario se encontraba con los ojos cerrados debido a ruidos del sensor y a el hecho de que las bioseñales varían mucho. Se podía observar que el clasificador era muy preciso en detectar ojos cerrados pero muy impreciso en detectar ojos abiertos. La precisión en ojos cerrados era de un $99\%$ y en ojos abiertos de un $25\%$.

Para intentar mejorar la precisión, se decidió aumentar el tamaño de la ventana con la expectativa de que al tener una mayor cantidad de valores, los picos anómalos que se generaban cuando el usuario estaba con los ojos abiertos, se redujeran ya que, al contar con más muestras, además de obtener picos anómalos, se obtienen los valores que corresponden al estado de ojos abiertos. Se podría decir que los picos anómalos se promedian con más valores. Cuando se trabaja con bioseñales, cuantos más datos se tomen, más robusta será la clasificación. El problema es que para tomar más datos se necesita más tiempo. Entonces, aquí aparece un compromiso entre robustez y latencia. Como en este proyecto la utilización fue en tiempo real, hubo que considerar seriamente este compromiso. El dispositivo utiliza una frecuencia de $10 \, Hz$ para los valores de potencia de \emph{Alpha} y se necesitaba una frecuencia mayor, por lo que se decidió calcular dicha potencia utilizando los datos brutos. El dispositivo envía un arreglo de cinco elementos. Como se mencionó anteriormente, el quinto valor es de referencia por lo que se ignora en el procesamiento. El procedimiento implementado fue el siguiente:

 \begin{enumerate}
 \item Obtener una ventana $256$ muestras, es decir, un segundo.
 \item Obtener la Transformada de \emph{Fourier} de la ventana.
 \item Quedarse únicamente con las frecuencias $8 \, Hz-13 \, Hz$.
 \item Realizar la DEP sobre esos valores.
 \end{enumerate}
 
Este procedimiento se aplica por cada uno de los cuatro electrodos. Por lo que cada segundo, se cuenta con cuatro valores. El vector de características se forma con estos cuatro valores de la siguiente manera:
 
\[
  \vec{v}^{\, }=
  \left[ {\begin{array}{cccc}
   \alpha_{AF7}  & \alpha_{AF8} & \alpha_{TP9} & \alpha_{TP10}  \     \end{array} } \right]
\] 

Con este vector de características, se alcanzó una precisión de hasta un $ 85 \%$. Esto se debe a que, si bien empeoro la precisión de detectar ojos cerrados, incrementó notablemente la de ojos abiertos.
 
En la etapa de entrenamiento, en lugar de tomar todos los valores, se ignoran los valores de transición. Cuando se le indica al usuario que abra o cierre los ojos, se descartan dos segundos antes y después de la transición de estados. Esto se debe a que los valores que corresponden a la transición no son significativos. Los que realmente importan son cuando se está en un estado u otro.
 
\subsection{EMG}

Una vez preparado el sistema de monitoreo EMG descripto en la seccion \ref{emg-hardware}, se puede comenzar a leer los datos. Los micro controladores \emph{Arduino} permiten comunicarse a una computadora mediante un puerto de serie que es establecido a traves de la conexión USB.  Para poder leer del puerto de serie desde el sistema operativo, es necesario conocer los parametros de la conexión (velocidad, paridad, cantidad de bits de información, etc.), y el nombre del puerto de serie. Los valores utilizados fueron los predeterminados utilizados en el programa de ejemplo referenciado en el manual del módulo EMG\cite{olimex-manual}.

El dispositivo cuenta con una frecuencia de muestreo de $256\, Hz$. Por el teorema de muestreo de Nyquist-Shannon, esto quiere decir que dadas estas muestras, solo es posible reconstruir señales con frecuencias iguales o inferiores a $128\, Hz$. Teniendo esto en mente, el procedimiento llevado a cabo para leer los datos de EMG fueron los siguientes:

 \begin{enumerate}
 \item Obtener una ventana $128$ muestras, es decir, medio segundo.
 \item Obtener la Transformada de \emph{Fourier} de la ventana.
 \item Quedarse únicamente con las frecuencias en el rango de $50 \, Hz-128 \, Hz$. Las frecuencias en el rango de $128 \, Hz-150 \, Hz$ no son capturadas.
 \item Separar el rango de frecuencias resultante en dos mitades: $50 \, Hz-89 \, Hz$ y $90 \, Hz-128 \, Hz$.
 \item Realizar la DEP sobre ambas mitades por separado.
 \end{enumerate}

Luego de haber realizado los pasos mencionados, el resultado son dos valores numéricos representativos de la intensidad de la señal recibida.  Utilizando estos dos valores, se construyo el vector de características de la señal EMG. Con este vector, se lograron precisiones de predicción muy altas (superiores a $ 95 \%$), utilizando tiempos de entrenamiento de alrededor de $5$ minutos.

Para el entrenamiento, el procedimiento fue simple. Primero, se preparo el sistema de monitoreo EMG, y se colocaron los electrodos sobre la piel del los músculos mencionados en la sección \ref{emg-hardware}. Luego, con el brazo y mano relajados, se comenzó a entrenar un clasificador con las muestras leídas y procesadas. A continuación se procedió a tensar el brazo y cerrar la mano con fuerza, con tal de generar una diferencia de potencial significativa, en intervalos intermitentes de alrededor de $15$ segundos. Durante todo el proceso, se le informa al clasificador a que categoría pertenece cada dato ingresado (musculo tensionado o relajado).

Al igual que en EEG, al transicionar de un estado de tension de musculo a otro, se ignora cierta cantidad de muestras luego del momento de la transición, ya que solo son de interés los datos leídos al mantener un estado de tension constante. 

Al realizar los experimentos, se noto que ocasionalmente los datos leídos contenían grandes cantidades de ruido, por lo que eran prácticamente inutilizables. El problema encontrado fue que el sujeto conectado al modulo EMG no estaba eléctricamente aislado al suelo, lo cual introducía ruido a los valores leídos. El problema fue resuelto asegurándose de que el sujeto utilizara calzado con suficiente aislación eléctrica, como por ejemplo botas o zapatillas deportivas.

\subsection{SPO2}

Como se mencionó anteriormente, el dispositivo elegido utilizaba un formato propietario. Por este motivo, no se podía obtener una correcta lectura de los datos. La única forma de obtener los datos era realizando una ingeniería inversa. Se investigó y se encontró el cómo era la estructura interna de cada paquete. Una vez que se podían leer paquetes, estos debían ser procesados. El ritmo cardíaco calculado por el sensor utiliza una ventana de 30 segundos. Esta duración era inaceptable para utilizar en tiempo real ya que se reflejaba el ritmo cardíaco de 30 antes, en lugar del actual. Por este motivo, se decidió calcular el ritmo cardíaco utilizando los picos.

El dispositivo obtiene $256$ muestras por segundo pero el ritmo cardíaco de una persona en reposo se encuentra entre $ 60$ - $100$. Por lo tanto, para cada latido, hay múltiples paquetes indicando que hubo un pico. Para evitar estimar incorrectamente, se consideró como un único pico a todos los paquetes continuos que indicaban que hubo un pico.

En una primera aproximación, se utilizó una ventana de $10$ segundos y se calculaba el ritmo cardíaco utilizando la técnica de promedio. Dicha técnica no resultó efectiva ya que el ritmo cardíaco contaba con grandes fluctuaciones lo que causaba que sea inutilizable en tiempo real. Luego, se empezó a utilizar la técnica de medir el tiempo entre latidos y realizar el promedio de los últimos seis valores. Esta técnica resultó efectiva indicando un ritmo cardíaco estable y preciso. Se comparó con el valor de ritmo cardíaco obtenido por el sensor para determinar si era preciso. A su vez se comparó con lo medido por un \emph{Apple Watch}.

En este sensor no se requería clasificar ningún estado por lo que no requirió reconocimiento de patrones.

\section{Desarrollo de universos 3D interactivos}

Para el desarrollo de universos 3D se decidió utilizar \emph{Unity 3D}. Se tomó esta decisión por diversas razones. Una de ellas fue que es multiplataforma. Permite desarrollar para \emph{MacOS, Windows, Linux, iOS, Anroid, entre otros.} Esto se debe a que utiliza como lenguaje \emph{C\#} el cual es multiplataforma. \emph{C\#} requiere de \emph{.NET}, que solo funciona en \emph{Windows}, para funcionar pero existe un proyecto llamado \emph{Mono} el cual es una implementación multiplataforma de \emph{.NET}.  Siendo usuarios de distintos sistemas operativos, que sea multiplataforma era crucial. Además, \emph{Unity} es robusto, es fácil de utilizar y cuenta con una gran comunidad, por lo que hay muchas extensiones.

\emph{Unity} es un motor para desarrollar vídeojuegos. Es un sistema de entidades y componentes. Las entidades son \emph{GameoOjects}. Estos son objetos que pueden tener múltiples componentes. Uno de esos componentes son los archivos de código fuente. Con dichos archivos se puede controlar a los objetos y alterar el estado. Otros ejemplos de componentes son materiales, cuerpos rígidos,etc. \emph{Unity} tiene un ciclo de vida, el cual es seguido por los \emph{GameObjects}. En la figura \ref{fig:unity-lifecycle} se puede observar una versión simplificada de dicho ciclo de vida.

Todos los \emph{GameObjects} también siguen dicho ciclo de vida. Cuando comienza el programa, luego de que se hayan inicializado las variables y el esto del juego, se llama a la función \emph{Awake()}. Aquí se pueden establecer referencias entre objectos para que luego puedan intercambiar información. En este momento, el juego ya está listo para comenzar. Se llama a \emph{Start()} para terminar con la inicialización. Luego comienza el ciclo de juego. Aquí se llama a \emph{Update()} y \emph{FixedUpdate()}. La diferencia entre ambos, es que \emph{Update} es llamado una vez por cuadro pero \emph{FixedUpdate} se encuentra ligado al motor físico. Por este motivo, puede ser llamado cero o más veces por cuadro. En cada actualización, el programador es responsable de realizar los cambios al estado del juego necesarios. Finalmente, se comienzan a liberar los recursos y se llama a \emph{OnDestroy}, en el cual se llevan a cabo las acciones necesarias antes de que finalice el juego.

 \begin{figure}[H]
	\centering
    \includegraphics[width=0.5\textwidth]{unity-lifecycle.png}
    \caption{Versión simplificada del ciclo de vida de \emph{Unity}.}
	\label{fig:unity-lifecycle}
\end{figure}

El método \emph{Update} fue elegido para leer datos de los sensores. El problema que esto traía, era que dicho método no puede ser bloqueado ya que el ciclo principal de \emph{Unity} se ejecuta en el \emph{Thread} principal. \emph{Update} debe procesar información rápidamente para que el motor continue con su ciclo. Ante esta limitación se decidió que los sensores operen en otro \emph{Thread}. De esta forma, una rutina podía leer y procesar información y el juego podía obtener dicha información en \emph{Update}. En todas las implementaciones realizadas se utilizó la misma arquitectura, la cual se puede observar en la figura  \ref{fig:architecture}.

 \begin{figure}[H]
	\centering
    \includegraphics[width=0.5\textwidth]{architecture.png}
    \caption{Arquitectura utilizada en los universos 3D.}
	\label{fig:architecture}
\end{figure}

Se cuenta con un \emph{Reader}, que es el encargado de obtener los datos del sensor. Esta instancia se ejecuta en otro \emph{Thread} ya que estas operaciones pueden ser bloqueantes. Dicha instancia, coloca los datos obtenidos por el sensor en una cola. Luego, \emph{Processor} puede leer esos datos sin inconvenientes. \emph{Processor} contiene un método \emph{Update}, el cual es llamado desde el ciclo del juego, es decir, desde el método \emph{Update} de la rutina que se ejecuta en \emph{Unity}. Cada vez que se llama a \emph{Update}, el procesador obtiene datos de la cola del lector (la deja vacía), los procesa y los deja disponibles para que el método \emph{Update} de \emph{Unity}, los pueda utilizar sin problemas. Es decir, en cada actualización se obtienen todos los datos no procesados en la actualización anterior y se procesan. Cabe destacar que \emph{Unity} no permitía el uso de \emph{ConcurrentQueue}, ya que utiliza una versión desactualizada de \emph{.NET}. Por este motivo, se realizó una implementación propia. Esta arquitectura nos permitió a su vez, desarrollar una aplicación en \emph{C\#}, por fuera de \emph{Unity}, con el fin de realizar pruebas y registrar sesiones de entrenamiento.

En todos los universos desarrollados se buscó que el uso de las bioseñales tenga sentido y no sea forzado. Es decir, que su sea lógico y cómodo para el usuario. Se buscó que mejoren la experiencia, en lugar de empeorarla. Si la predicción fallaba y el usuario se encontraba en otro estado, se buscaba que esta situación no perjudique al usuario. Es decir, que no le quite vida o decremente sus posibilidades de ganar. En el peor caso, que beneficie al usuario, en lugar de perjudicarlo.

\subsection{Universo 3D utilizando bioseñales cerebrales}

Se desarrolló un vídeojuego de terror en el que el usuario debía escaparse de un laberinto. Dicho laberinto es oscuro, está custodiado por \emph{Zombies} y hay bombas escondidas. El usuario cuenta con una pistola y los movimientos se controlan utilizando el teclado y el ratón. Como se mencionó anteriormente, se utilizaron ondas cerebrales para detectar si el usuario estaba con los ojos abiertos o cerrados. En este vídeojuego, cuando el usuario cierra los ojos, puede escuchar los sonidos que generan las bombas y las puede visualizar por algunos segundos, luego de abrir los ojos, para poder desactivarlas. A su vez, se acumula el tiempo que el usuario se encuentra con los ojos cerrados, y luego de abrir los ojos, se puede observar a los \emph{Zombies} a través de las paredes. Este habilidad dura tanto como los segundos acumulados con los ojos cerrados. El personaje puede escuchar y visualizar bombas y \emph{Zombies} ya que al cerrar los ojos, se concentra e incrementa la sensibilidad auditiva, por lo que puede escuchar tanto a los enemigos como a las bombas. Aumentar los sentidos es un recurso muy utilizado en muchos vídeojuegos. La diferencia es que en este vídeojuego, el usuario realmente se encuentra con los ojos cerrados por lo que se utiliza el estado actual en lugar de un simple botón.

La clase \emph{EEGProcessor} se encarga de obtener lecturas del cerebro de una cola. Dicha cola se encuentra en \emph{EEGReader} y es ésta clase es la que se encarga de leer los datos del sensor y publicarlos a la cola. \emph{EEGProcessor} permite que se especifique una lista de funciones a las cuales llamar una vez que se procesaron los datos. Luego de obtener 256 lecturas de cada electrodo, se calcula la \emph{FFT} para cada electrodo. Es en este instante en el que se llama a dichas funciones. De esta manera, una rutina en \emph{Unity} es llamada y obtiene la información necesaria del procesador en ese instante. En este caso, el estado de los ojos. En otras palabras, cuando el procesador tiene información para enviar, le notifica a la rutina de \emph{Unity} para que éste la utilice.

Como se utilizó reconocimiento de patrones, se implementó una interfaz para entrenar al clasificador. Dicho entrenamiento tiene una duración de cinco minutos, en los cuales se le indica al usuario que abra y cierre los ojos por períodos de tiempo aleatorio. Durante el entrenamiento se identifica el estado en el que está el usuario. Una vez finalizado el entrenamiento, el usuario puede comenzar a jugar.

Debido a que la precisión del clasificador no es tan cercana al $100\%$, se decidió establecer un umbral para determinar en que momento el usuario se encuentra con los ojos cerrados. Cada vez que se predice que se encuentra con los ojos abiertos, se decrementa un contador, y cada vez que se predice que se encuentra con los ojos cerrados, se incrementa. El contador tiene como valor mínimo cero y el valor máximo es establecido de acuerdo al usuario.  Luego, cuando el contador supera un umbral, se considera que los ojos están cerrados hasta que dicho contador se encuentre nuevamente por debajo del umbral. Al procesar las ondas cerebrales, se observó, que en ocasiones, aún cuando el usuario se encontraba con los ojos abiertos, las ondas \emph{Alpha}, obtenían valores muy altos. Por este motivo, podían ser clasificadas como ojos cerrados. Al utilizar un umbral, se impone la condición de que las ondas  \emph{Alpha} se encuentren elevadas por un determinado periodo de tiempo. Algo que no debería suceder al encontrarse con los ojos abiertos. Este comportamiento se controla con dos variables (umbral mínimo y umbral máximo) accesibles desde el menú de pausa. Si se identifica que el usuario registra valores de \emph{Alpha} elevados por períodos de una duración de tiempo determinada, se deben incrementar  tanto el umbral mínimo, como el máximo. En caso contrario, se deben decrementar. La utilización de este sistema, puede causar retardo en la detección de estado ya que se debe esperar a tener una mínima cantidad de lecturas de datos para determinar el estado. Por este motivo, se debía tomar una decisión de compromiso en el momento de elegir los valores. No debían ser muy bajos, ya que se iba a detectar falsamente que el usuario se encontraba con los ojos cerrados. Pero tampoco, debían ser muy altos porque el retardo iba a ser elevado.

\subsection{Universo 3D utilizando bioseñales de los músuclos}

Se desarrolló un universo 3D interactivo en el que el usuario al tensar el músculo acumula energía. Luego, al liberar la tensión, envía una bola eléctrica que impacta contra otros objetos. Cuanto mayor sea el tiempo que se mantiene tensión, mayor es la fuerza de la bola y mayor es la energía liberada en el impacto contra otros objetos. En el universo 3D se cuenta, por ejemplo, con barriles colocados uno encima del otro. Dichos barriles pueden ser derrumbados arrojando bolas. Se decidió utilizar la tensión para este tipo de ataque ya que si uno estuivera arrojando bolas eléctricas, un forma de cargarlas y generarlas, sería utilizando la fuerza. 

La fuerza se modelo como un simple contador. Cada actualización en la que el músculo se encuentra tenso, se incrementa el contador. Si se encuentra relajado, se decrementa el contador. Dicho contador nunca alcanza valores menores a $0$ y nunca valores mayores a un máximo establecido. Una vez que el contador supera un umbral, si se detecta una relajación, se libera la bola. Se puede observar una pequeña latencia al liberal la bola. Esto se debe a que, como se utilizan $128$ muestras para extraer las características y predecir un estado, se obtienen cambios de estado cada medio segundo.

Al igual que con el universo que utiliza información del EEG, aquí se cuenta con un lector y un procesador. El procesador también permite que otros objetos se subscriban a eventos. Cuando el procesador obtuvo la cantidad de muestras necesarias y las procesó, notifica a los objetos que se hayan suscrito. De esta manera, la rutina que se ejecuta en \emph{Unity} puede conocer el estado en cada actualización y realizar las acciones necesarias. Aquí no hizo falta la utilización de un umbral para determinar un cambio de estado, ya que la precisión era muy alta. Este universo también cuenta con una interfaz con instrucciones de entrenamiento.

\subsection{Universo 3D utilizando el ritmo cardíaco}

Se continuó con el desarrollo del vídeojuego en el que se utilizaron las bioseñales del cerebro. Se desarrolló un nuevo nivel que sucede luego de que el jugador escapara del laberinto. Al escapar del laberinto, éste se encuentra en el centro de un campo,  con una linterna y un arma, rodeado de \emph{Zombies}. El objetivo es sobrevivir a todas las olas de ataques de \emph{Zombies}. Cuando el jugador comienza a ponerse nervioso, el ritmo cardíaco aumenta. Se utiliza esta información para simular que al jugador le tiemblan las manos a causa de los nervios. Cuanto más alto es el ritmo cardíaco, más movimientos aleatorios realiza el arma, dificultando la tarea de apuntar. Este movimiento imita a la realidad, ya que cuando uno se encuentra nervioso, le resulta más difícil realizar acciones con las manos, como apuntar un arma. El jugador puede también quedarse sin municiones y sin batería en la linterna, lo que genera mayor nerviosismo en la persona porque no puede ver correctamente y no cuenta con ninguna forma de defenderse.

Aquí también se cuenta con un procesador (\emph{SPO2Processor} y un lector (\emph{SPO2Reader}. El procesador expone un método que permite obtener el ritmo cardíaco actual. De esta manera, la rutina en \emph{Unity} obtiene este valor en cada actualización y en base a él, realiza movimientos sobre la cámara. Dichos movimientos se modelaron utilizando funciones trigonométricas para que sean armónicas y agradables a la vista. La magnitud de los movimientos se controla con dos variables: mínimo y máximo. Una establece el umbral mínimo que se utiliza para determinar si el usuario está nervioso y la otra el máximo. Luego, si el el ritmo cardíaco es mayor al umbral mínimo, se interpola linealmente entre el máximo y el mínimo.